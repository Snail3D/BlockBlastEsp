<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>Block Blast</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;touch-action:none}
body{font-family:sans-serif;background:linear-gradient(135deg,#1a1a2e 0%,#16213e 50%,#0f3460 100%);min-height:100vh;display:flex;justify-content:center;align-items:center;padding:10px}
#game{max-width:380px}
.header{display:flex;justify-content:space-between;margin-bottom:10px}
.score-box{background:rgba(255,255,255,0.1);border-radius:10px;padding:8px 16px;text-align:center}
.score-label{font-size:10px;font-weight:700;color:#88ccff;letter-spacing:1px}
.score-value{font-size:20px;font-weight:700;color:#fff;text-shadow:0 2px 8px rgba(136,204,255,0.4)}
#canvas{background:rgba(255,255,255,0.05);border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,0.3);display:block}
#pieces{display:flex;gap:12px;justify-content:center;margin-top:15px;height:80px}
.piece-slot{width:70px;height:70px;background:rgba(255,255,255,0.08);border-radius:10px;display:flex;align-items:center;justify-content:center;position:relative}
.piece-slot canvas{cursor:grab;touch-action:none}
.combo{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:28px;font-weight:700;color:#ffdd00;text-shadow:0 0 20px rgba(255,221,0,0.8);pointer-events:none;opacity:0;transition:opacity 0.3s}
.combo.show{opacity:1;animation:comboPop 0.5s ease-out}
@keyframes comboPop{0%{transform:translate(-50%,-50%) scale(0)}50%{transform:translate(-50%,-50%) scale(1.2)}100%{transform:translate(-50%,-50%) scale(1)}}
@keyframes lineFlash{0%{opacity:1}50%{opacity:0.3}100%{opacity:1}}
.line-clear{animation:lineFlash 0.3s ease-out}
.dragging{position:fixed;pointer-events:none;z-index:1000;opacity:0.85;filter:drop-shadow(0 5px 15px rgba(0,0,0,0.4))}
</style>
</head>
<body>
<div id="game">
<div class="header">
<div class="score-box">
<div class="score-label">SCORE</div>
<div class="score-value" id="score">0</div>
</div>
<div class="score-box">
<div class="score-label">BEST</div>
<div class="score-value" id="best">0</div>
</div>
</div>
<div style="position:relative">
<canvas id="canvas" width="320" height="320"></canvas>
<div class="combo" id="combo"></div>
</div>
<div id="pieces"></div>
</div>
<script>
const G=8,CS=40;
const COLORS={cyan:'#00d4aa',blue:'#00a8cc',orange:'#ff8c42',yellow:'#ffdd00',green:'#7ec850',red:'#ff5252',purple:'#a855f7',pink:'#ff6b9d'};
const PIECES=[{shape:[[1]],color:COLORS.cyan},{shape:[[1,1]],color:COLORS.blue},{shape:[[1],[1]],color:COLORS.blue},{shape:[[1,1,1]],color:COLORS.green},{shape:[[1],[1],[1]],color:COLORS.green},{shape:[[1,1,1,1]],color:COLORS.orange},{shape:[[1],[1],[1],[1]],color:COLORS.orange},{shape:[[1,1],[1,1],[1,1]],color:COLORS.red},{shape:[[1],[1],[1],[1],[1],[1]],color:COLORS.red},{shape:[[1,1],[1,1],[1,1],[1,1],[1,1]],color:COLORS.pink},{shape:[[1,1],[1,1]],color:COLORS.yellow},{shape:[[1,1],[1,1]],color:COLORS.purple},{shape:[[1,0],[1,0],[1,1]],color:COLORS.red},{shape:[[1,1,1],[1,0,0]],color:COLORS.red},{shape:[[0,1],[0,1],[1,1]],color:COLORS.purple},{shape:[[1,0,0],[1,1,1]],color:COLORS.purple},{shape:[[1,1],[0,1],[0,1]],color:COLORS.pink},{shape:[[0,0,1],[1,1,1]],color:COLORS.pink},{shape:[[1,1],[1,1],[0,1,0]],color:COLORS.cyan},{shape:[[0,0,1],[1,1,1]],color:COLORS.cyan},{shape:[[1,1,1],[0,1,0]],color:COLORS.blue},{shape:[[0,1],[1,1],[0,1]],color:COLORS.blue},{shape:[[1,1,0],[0,1,1]],color:COLORS.green},{shape:[[0,1,1],[1,0,0]],color:COLORS.green}];
const COMBO_BONUS=[0,20,30,40,50,60,70,80,90,100];

let grid=Array(G).fill(null).map(()=>Array(G).fill(null));
let score=0,highScore=localStorage.highScore||0;
let current=[];
let dragPiece=null,dragIdx=-1,ghost=null;
let animations=[];

const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');

function init(){
  document.getElementById('best').textContent=highScore;
  spawnPieces();
  drawGrid();
  requestAnimationFrame(gameLoop);
}

function spawnPieces(){
  current=[];
  document.getElementById('pieces').innerHTML='';
  for(let i=0;i<3;i++){
    const p=PIECES[Math.floor(Math.random()*PIECES.length)];
    current.push(p);
    const slot=document.createElement('div');
    slot.className='piece-slot';
    slot.id='slot'+i;
    const cvs=document.createElement('canvas');
    const rows=p.shape.length,cols=p.shape[0].length;
    cvs.width=cols*18;
    cvs.height=rows*18;
    cvs.dataset.idx=i;
    drawPiece(cvs.getContext('2d'),p.shape,p.color,18);
    cvs.style.cursor='grab';
    cvs.addEventListener('mousedown',startDrag);
    cvs.addEventListener('touchstart',startDrag,{passive:false});
    slot.appendChild(cvs);
  }
}

function drawPiece(ctx,shape,color,size){
  shape.forEach((r,y)=>r.forEach((c,x)=>{
    if(c){
      const g=ctx.createLinearGradient(x*size+1,y*size+1,x+size,y+size);
      g.addColorStop(0,color);
      g.addColorStop(1,shadeColor(color,-15));
      ctx.fillStyle=g;
      ctx.beginPath();
      roundRect(ctx,x*size+1,y*size+1,size-2,size-2,3);
      ctx.fill();
      ctx.fillStyle='rgba(255,255,255,0.3)';
      ctx.beginPath();
      roundRect(ctx,x*size+3,y*size+3,size-6,size-6,2);
      ctx.fill();
    }
  }));
}

function shadeColor(c,p){
  const n=parseInt(c.replace('#',''),16),a=Math.round(2.55*p);
  return'#'+(0x1000000+(Math.min(255,Math.max(0,(n>>16)+a))<<16)+(Math.min(255,Math.max(0,((n>>8)&255)+a))<<8)+Math.min(255,Math.max(0,(n&255)+a))).toString(16).slice(1);
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.arc(x+r,y,r,Math.PI*1.5,0,Math.PI*2);
  ctx.arc(x+w-r,y,r,0,Math.PI*0.5);
  ctx.arc(x+w-r,y+h-r,r,Math.PI*0.5,Math.PI);
  ctx.arc(x+r,y+h-r,r,Math.PI,Math.PI*1.5);
  ctx.closePath();
}

function drawGrid(){
  ctx.fillStyle='#1e293b';
  ctx.fillRect(0,0,320,320);
  for(let y=0;y<G;y++){
    for(let x=0;x<G;x++){
      const px=x*CS,py=y*CS;
      if(grid[y][x]){
        const g=ctx.createLinearGradient(px,py,px+CS,py+CS);
        g.addColorStop(0,grid[y][x]);
        g.addColorStop(1,shadeColor(grid[y][x],-15));
        ctx.fillStyle=g;
        ctx.beginPath();
        roundRect(ctx,px+1,py+1,CS-2,CS-2,5);
        ctx.fill();
        ctx.fillStyle='rgba(255,255,255,0.2)';
        ctx.beginPath();
        roundRect(ctx,px+4,py+4,CS-10,8,3);
        ctx.fill();
      }else{
        ctx.fillStyle='rgba(255,255,255,0.03)';
        ctx.beginPath();
        roundRect(ctx,px+1,py+1,CS-2,CS-2,5);
        ctx.fill();
        ctx.strokeStyle='rgba(255,255,255,0.05)';
        ctx.lineWidth=1;
        ctx.stroke();
      }
    }
  }

  // Draw ghost
  if(ghost&&dragPiece){
    ctx.fillStyle=ghost.valid?'rgba(0,255,100,0.25)':'rgba(255,60,60,0.25)';
    ctx.strokeStyle=ghost.valid?'rgba(0,255,100,0.5)':'rgba(255,60,60,0.5)';
    ctx.lineWidth=2;
    dragPiece.shape.forEach((r,y)=>r.forEach((c,x)=>{
      if(c){
        const gx=(ghost.col+x)*CS,gy=(ghost.row+y)*CS;
        if(gy>=0&&gy<G&&gx>=0&&gx<G){
          ctx.beginPath();
          roundRect(ctx,gx+2,gy+2,CS-4,CS-4,5);
          ctx.fill();
          ctx.stroke();
        }
      }
    }));
  }

  // Draw animations
  animations=animations.filter(a=>{
    a.progress+=0.05;
    if(a.type==='clear'){
      ctx.fillStyle='rgba(255,255,255,0.5)';
      a.cells.forEach(c=>{
        ctx.beginPath();
        roundRect(ctx,c.x*CS+1,c.y*CS+1,CS-2,CS-2,5);
        ctx.fill();
      });
    }
    return a.progress<1;
  });
}

function gameLoop(){
  drawGrid();
  requestAnimationFrame(gameLoop);
}

function startDrag(e){
  e.preventDefault();
  const cvs=e.target;
  dragIdx=parseInt(cvs.dataset.idx);
  dragPiece=current[dragIdx];
  if(!dragPiece)return;

  const t=e.touches?e.touches[0]:e;
  const dc=document.createElement('canvas');
  dc.className='dragging';
  dc.width=dragPiece.shape[0].length*CS;
  dc.height=dragPiece.shape.length*CS;
  dc.style.left=(t.clientX-dc.width/2)+'px';
  dc.style.top=(t.clientY-dc.height/2)+'px';

  const dx=dc.getContext('2d');
  drawPiece(dx,dragPiece.shape,dragPiece.color,CS);
  document.body.appendChild(dc);

  if(cvs.parentElement){
    cvs.parentElement.style.opacity='0';
  }

  updateGhost(t.clientX,t.clientY);
}

function onDrag(e){
  if(!dragPiece)return;
  e.preventDefault();
  const t=e.touches?e.touches[0]:e;
  const dc=document.querySelector('.dragging');
  if(dc){
    dc.style.left=(t.clientX-dc.width/2)+'px';
    dc.style.top=(t.clientY-dc.height/2)+'px';
  }
  updateGhost(t.clientX,t.clientY);
}

function updateGhost(cx,cy){
  const r=canvas.getBoundingClientRect();
  const pw=dragPiece.shape[0].length*CS,ph=dragPiece.shape.length*CS;
  const col=Math.round((cx-r.left-pw/2)/CS);
  const row=Math.round((cy-r.top-ph/2)/CS);
  ghost={col,row,valid:canPlace(dragPiece.shape,row,col)};
}

function onDrop(e){
  const dc=document.querySelector('.dragging');
  if(ghost&&ghost.valid){
    placePiece(dragPiece,ghost.row,ghost.col);
    current[dragIdx]=null;
    const slot=document.getElementById('slot'+dragIdx);
    if(slot)slot.style.visibility='hidden';

    const cleared=checkLines();
    if(cleared>0){
      showCombo(cleared);
    }

    if(current.every(p=>p===null)){
      setTimeout(spawnPieces,300);
    }
  }

  if(dc)dc.remove();
  ghost=null;
  dragPiece=null;
  dragIdx=-1;
}

function canPlace(shape,row,col){
  for(let y=0;y<shape.length;y++){
    for(let x=0;x<shape[0].length;x++){
      if(shape[y][x]){
        if(row+y<0||row+y>=G||col+x<0||col+x>=G) return false;
        if(grid[row+y][col+x]) return false;
      }
    }
  }
  return true;
}

function placePiece(shape,color,row,col){
  shape.forEach((r,y)=>r.forEach((c,x)=>{
    if(c)grid[row+y][col+x]=color;
  }));

  // Add placement animation
  animations.push({
    type:'place',cells:shape.flatMap((r,y)=>r.map((c,x)=>c?[{x:col+x,y:row+y}]:[])).flat()
  });
}

function checkLines(){
  let rows=[],cols=[];

  for(let y=0;y<G;y++) if(grid[y].every(c=>c!==null)) rows.push(y);
  for(let x=0;x<G;x++){
    let full=true;
    for(let y=0;y<G;y++) if(!grid[y][x]) full=false;
    if(full) cols.push(x);
  }

  const total=rows.length+cols.length;
  if(total===0) return 0;

  // Animate clear
  animations.push({
    type:'clear',
    cells:rows.map(y=>Array(G).fill().map((_,x)=>({x,y}))).flat()
      .concat(cols.map(x=>Array(G).fill().map((_,y)=>({x,y}))).flat()),
    progress:0
  });

  // Count blocks
  let blocks=0;
  rows.forEach(y=>{for(let x=0;x<G;x++) if(grid[y][x]) blocks++;});
  cols.forEach(x=>{for(let y=0;y<G;y++) if(grid[y][x]&&!rows.includes(y)) blocks++;});

  // Clear
  rows.forEach(y=>{for(let x=0;x<G;x++) grid[y][x]=null;});
  cols.forEach(x=>{for(let y=0;y<G;y++) grid[y][x]=null;});

  // Score: 10 pts per block + combo bonus
  score+=blocks*10+COMBO_BONUS[Math.min(total,9)]||100;
  document.getElementById('score').textContent=score;

  if(score>highScore){
    highScore=score;
    localStorage.highScore=highScore;
    document.getElementById('best').textContent=highScore;
  }

  return total;
}

function showCombo(lines){
  const combo=document.getElementById('combo');
  const texts=['','NICE!','GOOD!','GREAT!','AWESOME!','INCREDIBLE!'];
  combo.textContent=texts[Math.min(lines,5)]+(lines>1?' x'+lines:'')+' +'+COMBO_BONUS[Math.min(lines,9)];
  combo.classList.add('show');
  setTimeout(()=>combo.classList.remove('show'),1000);
}

// Event listeners
document.addEventListener('mousemove',onDrag);
document.addEventListener('mouseup',onDrop);
document.addEventListener('touchmove',onDrag,{passive:false});
document.addEventListener('touchend',onDrop);

window.addEventListener('load',init);
</script>
</body>
</html>
